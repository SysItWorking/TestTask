#!/bin/bash

# Colors for output using tput
YELLOW=$(tput setaf 3)
GREEN=$(tput setaf 2)
RED=$(tput setaf 1)
RESET=$(tput sgr0)

# Function to calculate padding and align statuses
output_status() {
    local message=$1
    local status=$2
    local color=$3
    local total_width=85  # Total width for the message + status
    local message_length=${#message}  # Calculate the length of the message
    local padding=$((total_width - message_length))  # Calculate how many spaces to add

    # Output the message, padded with spaces, and then the status
    printf "%s%*s [%b%s%b]\n" "$message" "$padding" "" "$color" "$status" "$RESET"
}
###################################
# Step 1: Install Ansible package #
###################################
install_ansible() {
    if dpkg -s ansible &> /dev/null; then
        # Ansible is already installed
        output_status "Install Ansible package on the server" "Already installed" "$YELLOW"
    else
        # Try to install Ansible
        if apt install ansible -y &> /dev/null; then
            output_status "Install Ansible package on the server" "Done" "$GREEN"
        else
            output_status "Install Ansible package on the server" "error" "$RED"
            exit 1
        fi
    fi
}
#############################################
# Step 2: Install Ansible Galaxy collection #
#############################################
install_ansible_galaxy() {
    if ansible-galaxy collection list | grep -q 'community.general'; then
        # Collection is already installed
        output_status "Install Ansible Galaxy collection" "Already installed" "$YELLOW"
    else
        # Try to install the collection
        if ansible-galaxy collection install community.general &> /dev/null; then
            output_status "Install Ansible Galaxy collection" "Done" "$GREEN"
        else
            output_status "Install Ansible Galaxy collection" "error" "$RED"
            exit 1
        fi
    fi
}
#######################################
# Step 3: Create the ansible.cfg file #
#######################################
create_ansible_cfg() {
    local ansible_cfg_file="/etc/ansible/ansible.cfg"

    if [ -f "$ansible_cfg_file" ]; then
        # File already exists
        output_status "Create the main 'ansible.cfg' file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible && cat <<EOL > "$ansible_cfg_file"
[defaults]
inventory = /etc/ansible/hosts
remote_user = deploy
ask_pass = false
ask_become_pass = false
roles_path = /etc/ansible/roles
EOL
        then
            output_status "Create the main 'ansible.cfg' file" "Done" "$GREEN"
        else
            output_status "Create the main 'ansible.cfg' file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 4: Create the ansible directory and configure the Inventory file #
#########################################################################
create_inventory_file() {
    local inventory_file="/etc/ansible/hosts"

    if [ -f "$inventory_file" ]; then
        # Inventory file already exists
        output_status "Create the 'ansible' directory and configure Inventory file" "Already created" "$YELLOW"
    else
        # Try to create the directory and inventory file with the specified content
        if mkdir -p /etc/ansible && cat <<EOL > "$inventory_file"
[lb]
loadbalancing ansible_host=127.0.0.1 ansible_connection=local ansible_become=true

[webservers]
web1 ansible_host=172.21.0.3 ansible_user=deploy ansible_port=7856 ansible_ssh_private_key_file=/home/deploy/.ssh/id_rsa ansible_become=true
web2 ansible_host=172.21.0.4 ansible_user=deploy ansible_port=7856 ansible_ssh_private_key_file=/home/deploy/.ssh/id_rsa ansible_become=true
EOL
        then
            output_status "Create the 'ansible' directory and configure Inventory file" "Done" "$GREEN"
        else
            output_status "Create the 'ansible' directory and configure Inventory file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 5: Create the 'ansible' directory and configure Inventory file   #
#########################################################################

create_directory_structure() {
    # Define an array of directories to create
    local directories=(
        "/etc/ansible/playbooks"
        "/etc/ansible/roles/apache_install/tasks"
        "/etc/ansible/roles/apache_install/handlers"
        "/etc/ansible/roles/apache_install/defaults"
        "/etc/ansible/roles/php_install/tasks"
        "/etc/ansible/roles/php_install/handlers"
        "/etc/ansible/roles/php_install/defaults"
        "/etc/ansible/roles/php_install/templates"
        "/etc/ansible/roles/user_management/tasks"
        "/etc/ansible/roles/user_management/defaults"
        "/etc/ansible/roles/vhost_configuration/tasks"
        "/etc/ansible/roles/vhost_configuration/templates"
        "/etc/ansible/roles/mariadb_install/tasks"
        "/etc/ansible/roles/mariadb_install/handlers"
        "/etc/ansible/roles/mariadb_install/templates"
        "/etc/ansible/roles/firewall/tasks"
        "/etc/ansible/roles/firewall/defaults"
        "/etc/ansible/roles/hosts_management/tasks"
        "/etc/ansible/roles/mariadb_install/vars"
        "/etc/ansible/roles/mariadb_replication/tasks"
        "/etc/ansible/roles/nfs_server_setup/tasks"
        "/etc/ansible/roles/nfs_server_setup/defaults"
        "/etc/ansible/roles/nfs_client_mount/tasks"
        "/etc/ansible/roles/wordpress_install/tasks"
        "/etc/ansible/roles/wordpress_config/tasks"
        "etc/ansible/roles/certificate_generation/tasks"
        "/etc/ansible/roles/certificate_generation/defaults"
        "/etc/ansible/roles/haproxy_install/defaults"
        "/etc/ansible/roles/haproxy_install/handlers"
        "/etc/ansible/roles/haproxy_install/tasks"
        "/etc/ansible/roles/haproxy_install/templates"
        "/etc/ansible/roles/haproxy_install/files/error_pages"
    )

    local all_created=true  # Flag to track overall success
    local already_exists=false  # Flag to track if directories were already created

    for dir in "${directories[@]}"; do
        if [ -d "$dir" ]; then
            already_exists=true
        else
            if mkdir -p "$dir"; then
                continue
            else
                all_created=false
            fi
        fi
    done

    # Output status based on the results
    if [ "$all_created" = true ] && [ "$already_exists" = false ]; then
        output_status "Creating the 'ansible' directories structure" "Done" "$GREEN"
    elif [ "$all_created" = true ] && [ "$already_exists" = true ]; then
        output_status "Creating the 'ansible' directories structure" "Already created" "$YELLOW"
    else
        output_status "Creating the 'ansible' directories structure" "error" "$RED"
        exit 1
    fi
}

#########################################################################
# Step 6: Create file which will contain variables for Apache role      #
#########################################################################

create_apache_variables_file() {
    local apache_vars_file="/etc/ansible/roles/apache_install/defaults/main.yml"

    if [ -f "$apache_vars_file" ]; then
        # File already exists
        output_status "Create the Apache variables file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/apache_install/defaults && cat <<EOL > "$apache_vars_file"
server_name: testtask.com
doc_root: "/var/www/{{ user }}/public_html"
log_dir: "/var/www/{{ user }}/logs"
cgi_dir: "/var/www/{{ user }}/cgi-bin"
apache_suexec_package: "apache2-suexec-pristine"
apache_sites_available: "/etc/apache2/sites-available"
apache_sites_enabled: "/etc/apache2/sites-enabled"
apache_configtest_cmd: "apachectl configtest"
EOL
        then
            output_status "Create the Apache variables file" "Done" "$GREEN"
        else
            output_status "Create the Apache variables file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 7: Create tasks file to install and configure Apache Server      #
#########################################################################

create_apache_tasks_file() {
    local apache_tasks_file="/etc/ansible/roles/apache_install/tasks/main.yml"

    if [ -f "$apache_tasks_file" ]; then
        # File already exists
        output_status "Create the Apache tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/apache_install/tasks && cat <<EOL > "$apache_tasks_file"
---
- name: Install Apache web server
  apt:
    name: apache2
    state: present
    update_cache: yes
  register: apache_install  # Register the result of the task

- name: Print message if Apache was already installed
  debug:
    msg: "Apache is already installed."
  when: apache_install.changed == false  # Output message if no changes

- name: Install Apache suexec module (pristine version)
  apt:
    name: "{{ apache_suexec_package }}"
    state: present
    update_cache: yes

- name: Enable Apache mod_rewrite
  apache2_module:
    name: rewrite
    state: present
  notify: check_apache_config

- name: Enable Apache mod_suexec
  apache2_module:
    name: suexec
    state: present
  notify: check_apache_config

- name: Enable Apache mod_proxy
  apache2_module:
    name: proxy
    state: present
  notify: check_apache_config

- name: Enable Apache mod_proxy_fcgi
  apache2_module:
    name: proxy_fcgi
    state: present
  notify: check_apache_config

# Add task to enable SSL module
- name: Enable Apache SSL module
  apache2_module:
    name: ssl
    state: present
  notify: check_apache_config

- name: Overwrite /etc/apache2/ports.conf with the required content
  copy:
    dest: /etc/apache2/ports.conf
    content: |
      Listen 80

      <IfModule ssl_module>
          Listen 443
      </IfModule>

      <IfModule mod_gnutls.c>
          Listen 443
      </IfModule>
  notify: restart_apache

# Disable default Apache site
- name: Disable default Apache site
  command: a2dissite 000-default.conf
  notify: check_apache_config

# Check Apache service status before triggering handlers
- name: Check Apache service status
  service:
    name: apache2
    state: started
  register: apache_status

# Optionally, reload Apache configuration after changes
- name: Restart Apache if configuration was changed
  service:
    name: apache2
    state: restarted
  when: apache_status.state == "started"
EOL
        then
            output_status "Create the Apache tasks file" "Done" "$GREEN"
        else
            output_status "Create the Apache tasks file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 8: Create handlers file to manage Apache configuration           #
#########################################################################

create_apache_handlers_file() {
    local apache_handlers_file="/etc/ansible/roles/apache_install/handlers/main.yml"

    if [ -f "$apache_handlers_file" ]; then
        # File already exists
        output_status "Create the Apache handlers file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/apache_install/handlers && cat <<EOL > "$apache_handlers_file"
---
# Handler to check Apache configuration
- name: check_apache_config
  command: apachectl configtest
  notify:
    - restart_apache

# Handler for restarting Apache service if it is running
- name: restart_apache
  service:
    name: apache2
    state: restarted
  when: apache_status.state == "started"

# Fallback: start Apache if it is not running
- name: start_apache_if_not_running
  service:
    name: apache2
    state: started
  when: apache_status.state != "started"

# Handler for reloading Apache (новый хэндлер)
- name: reload_apache
  service:
    name: apache2
    state: reloaded
EOL
        then
            output_status "Create the Apache handlers file" "Done" "$GREEN"
        else
            output_status "Create the Apache handlers file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 9: Create variables file for PHP Install role                    #
#########################################################################

create_php_variables_file() {
    local php_vars_file="/etc/ansible/roles/php_install/defaults/main.yml"

    if [ -f "$php_vars_file" ]; then
        # File already exists
        output_status "Create the PHP variables file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/php_install/defaults && cat <<EOL > "$php_vars_file"
php_version: "8.3"
php_fpm_pool_dir: "/etc/php/{{ php_version }}/fpm/pool.d"
php_fpm_sock_dir: "/run/php"
EOL
        then
            output_status "Create the PHP variables file" "Done" "$GREEN"
        else
            output_status "Create the PHP variables file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 10: Create tasks file for PHP 8.3 installation                   #
#########################################################################

create_php_tasks_file() {
    local php_tasks_file="/etc/ansible/roles/php_install/tasks/main.yml"

    if [ -f "$php_tasks_file" ]; then
        # File already exists
        output_status "Create the PHP tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/php_install/tasks && cat <<EOL > "$php_tasks_file"
---
# Install gnupg and lsb-release for repository management
- name: Install gnupg and lsb-release
  apt:
    name:
      - gnupg
      - lsb-release
    state: present
    update_cache: yes

# Import GPG key for Sury repository
- name: Import Sury GPG key
  apt_key:
    url: https://packages.sury.org/php/apt.gpg
    state: present

# Get distribution codename (e.g., bookworm, bullseye)
- name: Get distribution codename
  command: lsb_release -sc
  register: dist_codename

# Add Sury PHP repository for Debian with dynamic codename
- name: Add Sury PHP repository for Debian
  apt_repository:
    repo: "deb https://packages.sury.org/php/ {{ dist_codename.stdout }} main"
    state: present
    filename: "/etc/apt/sources.list.d/php.list"

# Update apt cache after adding the repository
- name: Update apt cache
  apt:
    update_cache: yes

# Install PHP 8.3 and PHP-FPM
- name: Install PHP 8.3 and PHP-FPM
  apt:
    name: "{{ item }}"
    state: present
  loop:
    - php8.3
    - php8.3-fpm
    - php8.3-mysql
    - php8.3-cli
    - php8.3-curl
    - php8.3-gd
    - php8.3-xml
    - php8.3-mbstring
    - php8.3-zip
    - php8.3-soap
    - php8.3-intl
  notify: restart_php_fpm

# Configure PHP-FPM pool for 'web' user
- name: Configure PHP-FPM pool for 'web'
  template:
    src: /etc/ansible/roles/php_install/templates/php-fpm-pool.j2
    dest: "{{ php_fpm_pool_dir }}/{{ user }}.conf"
  notify: restart_php_fpm

# Checking PHP-FPM Status
- name: Check if php8.3-fpm is running
  ansible.builtin.systemd:
    name: php8.3-fpm
    state: started
  register: php_fpm_service_status
EOL
        then
            output_status "Create the PHP tasks file" "Done" "$GREEN"
        else
            output_status "Create the PHP tasks file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 11: Create PHP-FPM pool configuration template                   #
#########################################################################

create_php_fpm_template() {
    local php_fpm_template="/etc/ansible/roles/php_install/templates/php-fpm-pool.j2"

    if [ -f "$php_fpm_template" ]; then
        # File already exists
        output_status "Create the PHP-FPM pool configuration template" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/php_install/templates && cat <<EOL > "$php_fpm_template"
[{{ user }}]
user = {{ user }}
group = {{ group }}
listen = "{{ php_fpm_sock_dir }}/php{{ php_version }}-fpm-{{ user }}.sock"
listen.owner = {{ user }}
listen.group = {{ group }}
listen.mode = 0660

pm = dynamic
pm.max_children = 10
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
pm.max_requests = 500

php_admin_value[open_basedir] = /var/www/{{ user }}/public_html:/usr/share/php:/tmp
php_admin_value[upload_tmp_dir] = /var/www/{{ user }}/tmp
php_admin_value[session.save_path] = /var/www/{{ user }}/tmp
EOL
        then
            output_status "Create the PHP-FPM pool configuration template" "Done" "$GREEN"
        else
            output_status "Create the PHP-FPM pool configuration template" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 12: Create handlers file for PHP-FPM management                  #
#########################################################################

create_php_fpm_handlers_file() {
    local php_fpm_handlers_file="/etc/ansible/roles/php_install/handlers/main.yml"

    if [ -f "$php_fpm_handlers_file" ]; then
        # File already exists
        output_status "Create the PHP-FPM handlers file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/php_install/handlers && cat <<EOL > "$php_fpm_handlers_file"
---
# Restart PHP-FPM if it is already running
- name: restart_php_fpm
  ansible.builtin.systemd:
    name: php8.3-fpm
    state: restarted
  when: php_fpm_service_status.status == 'running'

# Starting PHP-FPM if it is not running
- name: start_php_fpm_if_not_running
  ansible.builtin.systemd:
    name: php8.3-fpm
    state: started
  when: php_fpm_service_status.status != 'running'
EOL
        then
            output_status "Create the PHP-FPM handlers file" "Done" "$GREEN"
        else
            output_status "Create the PHP-FPM handlers file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 13: Create variables file for User Management role               #
#########################################################################

create_user_management_variables_file() {
    local user_management_vars_file="/etc/ansible/roles/user_management/defaults/main.yml"

    if [ -f "$user_management_vars_file" ]; then
        # File already exists
        output_status "Create the User Management variables file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/user_management/defaults && cat <<EOL > "$user_management_vars_file"
user: "web"
group: "web"
doc_root: "/var/www/{{ user }}/public_html"
log_dir: "/var/www/{{ user }}/logs"
cgi_dir: "/var/www/{{ user }}/cgi-bin"
EOL
        then
            output_status "Create the User Management variables file" "Done" "$GREEN"
        else
            output_status "Create the User Management variables file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 14: Create tasks file for User Management role                   #
#########################################################################

create_user_management_tasks_file() {
    local user_management_tasks_file="/etc/ansible/roles/user_management/tasks/main.yml"

    if [ -f "$user_management_tasks_file" ]; then
        # File already exists
        output_status "Create the User Management tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/user_management/tasks && cat <<EOL > "$user_management_tasks_file"
---
- name: Create groups
  group:
    name: "{{ item.group }}"
  with_items:
    - { name: "web", group: "web" }

- name: Create users
  user:
    name: "{{ item.name }}"
    group: "{{ item.group }}"
    home: "/var/www/{{ item.name }}"
    createhome: yes
    shell: /bin/bash
  with_items:
    - { name: "web", group: "web" }

- name: Set permissions for the web directory
  file:
    path: "/var/www/{{ item.name }}/public_html"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.group }}"
    mode: '0755'
  with_items:
    - { name: "web", group: "web" }

- name: Create logs directory for the site
  file:
    path: "/var/www/{{ item.name }}/logs"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.group }}"
    mode: '0755'
  with_items:
    - { name: "web", group: "web" }

- name: Create cgi-bin directory for the site
  file:
    path: "/var/www/{{ item.name }}/cgi-bin"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.group }}"
    mode: '0755'
  with_items:
    - { name: "web", group: "web" }
EOL
        then
            output_status "Create the User Management tasks file" "Done" "$GREEN"
        else
            output_status "Create the User Management tasks file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 15: Create tasks file for setting up virtual hosts               #
#########################################################################

create_vhost_tasks_file() {
    local vhost_tasks_file="/etc/ansible/roles/vhost_configuration/tasks/main.yml"

    if [ -f "$vhost_tasks_file" ]; then
        # File already exists
        output_status "Create the Virtual Host tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/vhost_configuration/tasks && cat <<EOL > "$vhost_tasks_file"
---
- name: Configure virtual host
  template:
    src: /etc/ansible/roles/vhost_configuration/templates/vhost.j2
    dest: "{{ apache_sites_available }}/{{ server_name }}.conf"
  notify: check_apache_config

- name: Enable the site
  command: a2ensite {{ server_name }}.conf
  notify: check_apache_config
EOL
        then
            output_status "Create the Virtual Host tasks file" "Done" "$GREEN"
        else
            output_status "Create the Virtual Host tasks file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 16: Create template for virtual host                             #
#########################################################################

create_vhost_template() {
    local vhost_template="/etc/ansible/roles/vhost_configuration/templates/vhost.j2"

    if [ -f "$vhost_template" ]; then
        # File already exists
        output_status "Create the Virtual Host template" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/vhost_configuration/templates && cat <<EOL > "$vhost_template"
<VirtualHost *:80>
    ServerName {{ server_name }}
    ServerAlias www.{{ server_name }}
    ErrorLog "{{ log_dir }}/error.log"
    CustomLog "{{ log_dir }}/access.log" common

    # Redirect all HTTP requests to HTTPS
    RewriteEngine On
    RewriteCond %{HTTPS} !=on
    RewriteRule ^/?(.*) https://%{SERVER_NAME}/$1 [R=301,L]
</VirtualHost>

<VirtualHost *:443>
    DocumentRoot "{{ doc_root }}"
    ServerName {{ server_name }}
    ServerAlias www.{{ server_name }}
    ErrorLog "{{ log_dir }}/ssl-error.log"
    CustomLog "{{ log_dir }}/ssl-access.log" common

    SSLEngine on
    SSLCertificateFile    "{{ ssl_cert_file }}"
    SSLCertificateKeyFile "{{ ssl_cert_key_file }}"

    <Directory "{{ doc_root }}">
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    <FilesMatch \.php$>
        SetHandler "proxy:unix:/run/php/php{{ php_version }}-fpm.sock|fcgi://localhost/"
    </FilesMatch>

    ScriptAlias /cgi-bin/ "{{ cgi_dir }}"
    <Directory "{{ cgi_dir }}">
        AllowOverride None
        Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
        Require all granted
    </Directory>
</VirtualHost>
EOL
        then
            output_status "Create the Virtual Host template" "Done" "$GREEN"
        else
            output_status "Create the Virtual Host template" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 17: Create tasks file for MariaDB installation                  #
#########################################################################

create_mariadb_tasks_file() {
    local mariadb_tasks_file="/etc/ansible/roles/mariadb_install/tasks/main.yml"

    if [ -f "$mariadb_tasks_file" ]; then
        # File already exists
        output_status "Create the MariaDB tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/mariadb_install/tasks && cat <<EOL > "$mariadb_tasks_file"
---
- name: Ensure Python 3 and MySQL libraries are installed
  apt:
    name:
      - python3
      - python3-pip
      - python3-mysqldb
      - python3-pymysql
    state: present
    update_cache: yes

- name: Ensure MariaDB is installed
  apt:
    name: mariadb-server
    state: present
    update_cache: yes

- name: Ensure MariaDB is started and running
  service:
    name: mysql
    state: started
    enabled: yes

# Applying a Configuration Template for Replication
- name: Set up my.cnf for replication
  template:
    src: /etc/ansible/roles/mariadb_install/templates/my.cnf.j2
    dest: /etc/mysql/my.cnf
    owner: mysql
    group: mysql
    mode: '0644'
  register: mariadb_config_updated

# Restarting MariaDB after changing configuration
- name: Restart MariaDB if configuration changed
  service:
    name: mysql
    state: restarted
  when: mariadb_config_updated.changed == true

# Create a user for replication
- name: Create replication user
  mysql_user:
    name: "{{ mariadb_replication_user }}"
    password: "{{ mariadb_replication_password }}"
    priv: "*.*:REPLICATION SLAVE"
    host: '%'
    state: present
    login_unix_socket: /var/run/mysqld/mysqld.sock

# Create a user for replication on web1 with access from IP web2
- name: Create replication user for web2 on web1
  mysql_user:
    name: "{{ mariadb_replication_user }}"
    password: "{{ mariadb_replication_password }}"
    priv: "*.*:REPLICATION SLAVE"
    host: "{{ hostvars['web2'].ansible_host }}"  # IP второго сервера (web2)
    state: present
    login_user: root
    login_unix_socket: /var/run/mysqld/mysqld.sock

# Create a user for replication on web2 with access from IP web1
- name: Create replication user for web1 on web2
  mysql_user:
    name: "{{ mariadb_replication_user }}"
    password: "{{ mariadb_replication_password }}"
    priv: "*.*:REPLICATION SLAVE"
    host: "{{ hostvars['web1'].ansible_host }}"  # IP первого сервера (web1)
    state: present
    login_user: root
    login_unix_socket: /var/run/mysqld/mysqld.sock

# Task for creating database and user for WordPress

- name: Create a Database for WordPress
  mysql_db:
    name: wordpress_db
    state: present
    login_user: root
    login_unix_socket: /var/run/mysqld/mysqld.sock

- name: Create a user for WordPress
  mysql_user:
    name: wp_user
    password: testtask2024
    priv: "wordpress_db.*:ALL"
    host: '%'
    state: present
    login_user: root
    login_unix_socket: /var/run/mysqld/mysqld.sock

- name: Apply Privileges to WordPress User
  mysql_user:
    name: wp_user
    host: '%'
    priv: "wordpress_db.*:ALL"
    state: present
    login_user: root
    login_unix_socket: /var/run/mysqld/mysqld.sock
EOL
        then
            output_status "Create the MariaDB tasks file" "Done" "$GREEN"
        else
            output_status "Create the MariaDB tasks file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 18: Create template for MariaDB configuration (replication)      #
#########################################################################

create_mariadb_template() {
    local mariadb_template="/etc/ansible/roles/mariadb_install/templates/my.cnf.j2"

    if [ -f "$mariadb_template" ]; then
        # File already exists
        output_status "Create the MariaDB configuration template" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/mariadb_install/templates && cat <<EOL > "$mariadb_template"
[mysqld]
server-id = {{ mariadb_server_id }}
log_bin = {{ ansible_hostname }}-bin.log
relay-log = {{ ansible_hostname }}-relay-bin.log
auto-increment-increment = 2
auto-increment-offset = {{ mariadb_server_id }}
binlog_do_db = {{ mariadb_wp_db_name }} 
log_slave_updates = 1
skip_slave_start = 1
skip-name-resolve
EOL
        then
            output_status "Create the MariaDB configuration template" "Done" "$GREEN"
        else
            output_status "Create the MariaDB configuration template" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 19: Create handler file to restart MariaDB after configuration   #
#########################################################################

create_mariadb_handler_file() {
    local mariadb_handler_file="/etc/ansible/roles/mariadb_install/handlers/main.yml"

    if [ -f "$mariadb_handler_file" ]; then
        # File already exists
        output_status "Create the MariaDB handler file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/mariadb_install/handlers && cat <<EOL > "$mariadb_handler_file"
---
- name: Restart MariaDB
  service:
    name: mysql
    state: restarted
EOL
        then
            output_status "Create the MariaDB handler file" "Done" "$GREEN"
        else
            output_status "Create the MariaDB handler file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 20: Create variable file for MariaDB installation role           #
#########################################################################

create_mariadb_vars_file() {
    local mariadb_vars_file="/etc/ansible/roles/mariadb_install/vars/main.yml"

    if [ -f "$mariadb_vars_file" ]; then
        # File already exists
        output_status "Create the MariaDB variable file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/mariadb_install/vars && cat <<EOL > "$mariadb_vars_file"
mariadb_wp_db_name: "wordpress"
mariadb_server_id_offset: 1
# Dynamically set mariadb_server_id based on inventory_hostname:
mariadb_server_id: "{{ play_hosts.index(inventory_hostname) + mariadb_server_id_offset }}"
EOL
        then
            output_status "Create the MariaDB variable file" "Done" "$GREEN"
        else
            output_status "Create the MariaDB variable file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 21: Create tasks file for Firewall Role                          #
#########################################################################

create_firewall_tasks_file() {
    local firewall_tasks_file="/etc/ansible/roles/firewall/tasks/main.yml"

    if [ -f "$firewall_tasks_file" ]; then
        # File already exists
        output_status "Create the Firewall tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/firewall/tasks && cat <<EOL > "$firewall_tasks_file"
---
- name: Open port 3306 for internal network
  ufw:
    rule: allow
    port: '3306'
    proto: tcp
    from_ip: "{{ firewall_allowed_ip }}"
  become: true

- name: Allow port 2049/tcp for NFS
  ufw:
    rule: allow
    port: '2049'
    proto: tcp
    from_ip: "{{ firewall_allowed_ip }}"
  become: true

- name: Allow port 111/tcp and udp
  ufw:
    rule: allow
    port: '111'
    proto: tcp
    from_ip: "{{ firewall_allowed_ip }}"
  become: true

- name: Allow port 20048/tcp for NFS
  ufw:
    rule: allow
    port: '20048'
    proto: tcp
    from_ip: "{{ firewall_allowed_ip }}"
  become: true

- name: Allow port 875/tcp and udp
  ufw:
    rule: allow
    port: '875'
    proto: tcp
    from_ip: "{{ firewall_allowed_ip }}"
  become: true

- name: Allow port 443/tcp and udp
  ufw:
    rule: allow
    port: '443'
    proto: tcp
    from_ip: "{{ firewall_allowed_ip }}"
  become: true

- name: Allow port 80/tcp and udp
  ufw:
    rule: allow
    port: '80'
    proto: tcp
    from_ip: "{{ firewall_allowed_ip }}"
  become: true
EOL
        then
            output_status "Create the Firewall tasks file" "Done" "$GREEN"
        else
            output_status "Create the Firewall tasks file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 22: Create variables file for Firewall Role                      #
#########################################################################

create_firewall_vars_file() {
    local firewall_vars_file="/etc/ansible/roles/firewall/defaults/main.yml"

    if [ -f "$firewall_vars_file" ]; then
        # File already exists
        output_status "Create the Firewall variables file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/firewall/defaults && cat <<EOL > "$firewall_vars_file"
---
firewall_allowed_ip: "172.21.0.0/24"
EOL
        then
            output_status "Create the Firewall variables file" "Done" "$GREEN"
        else
            output_status "Create the Firewall variables file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 23: Create tasks file for adding entries to /etc/hosts           #
#########################################################################

create_hosts_management_tasks_file() {
    local hosts_management_tasks_file="/etc/ansible/roles/hosts_management/tasks/main.yml"

    if [ -f "$hosts_management_tasks_file" ]; then
        # File already exists
        output_status "Create the Hosts Management tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/hosts_management/tasks && cat <<EOL > "$hosts_management_tasks_file"
---
# Adding an entry to /etc/hosts for each host
- name: Add hostname for webserver1 and webserver2 in /etc/hosts
  lineinfile:
    dest: /etc/hosts
    regexp: '^{{ ansible_host }}'
    line: "{{ ansible_host }} {{ inventory_hostname }}"
  become: true
EOL
        then
            output_status "Create the Hosts Management tasks file" "Done" "$GREEN"
        else
            output_status "Create the Hosts Management tasks file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 24: Create tasks file for MariaDB replication                    #
#########################################################################

create_mariadb_replication_tasks_file() {
    local mariadb_replication_tasks_file="/etc/ansible/roles/mariadb_replication/tasks/main.yml"

    if [ -f "$mariadb_replication_tasks_file" ]; then
        # File already exists
        output_status "Create the MariaDB Replication tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/mariadb_replication/tasks && cat <<EOL > "$mariadb_replication_tasks_file"
---
# Stop replication on both servers before setting up the master
- name: Stop replication on both servers
  mysql_replication:
    mode: stopreplica
    login_unix_socket: /var/run/mysqld/mysqld.sock
  ignore_errors: yes

# Get Master Status on web1
- name: Get Master Status on web1
  mysql_query:
    login_unix_socket: /var/run/mysqld/mysqld.sock
    query: "SHOW MASTER STATUS;"
  register: web1_master_status
  delegate_to: web1
  ignore_errors: yes
  changed_when: false

# Get Master Status on web2
- name: Get Master Status on web2
  mysql_query:
    login_unix_socket: /var/run/mysqld/mysqld.sock
    query: "SHOW MASTER STATUS;"
  register: web2_master_status
  delegate_to: web2
  ignore_errors: yes
  changed_when: false

# Set replication for web1 (pointing to web2)
- name: Set replication for web1 (pointing to web2)
  mysql_replication:
    mode: changeprimary
    primary_host: "{{ hostvars['web2'].ansible_host }}"
    primary_user: "{{ mariadb_replication_user }}"
    primary_password: "{{ mariadb_replication_password }}"
    master_log_file: "{{ web2_master_status.query_result[0][0]['File'] }}"
    master_log_pos: "{{ web2_master_status.query_result[0][0]['Position'] }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
  delegate_to: web1

# Set replication for web2 (pointing to web1)
- name: Set replication for web2 (pointing to web1)
  mysql_replication:
    mode: changeprimary
    primary_host: "{{ hostvars['web1'].ansible_host }}"
    primary_user: "{{ mariadb_replication_user }}"
    primary_password: "{{ mariadb_replication_password }}"
    master_log_file: "{{ web1_master_status.query_result[0][0]['File'] }}"
    master_log_pos: "{{ web1_master_status.query_result[0][0]['Position'] }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
  delegate_to: web2

# Start replication on web1
- name: Start replication on web1
  mysql_query:
    login_unix_socket: /var/run/mysqld/mysqld.sock
    query: "START SLAVE;"
  delegate_to: web1

# Start replication on web2
- name: Start replication on web2
  mysql_query:
    login_unix_socket: /var/run/mysqld/mysqld.sock
    query: "START SLAVE;"
  delegate_to: web2

# Check replication status on web1
- name: Check replication status on web1
  mysql_query:
    login_unix_socket: /var/run/mysqld/mysqld.sock
    query: "SHOW SLAVE STATUS;"
  register: web1_replication_status
  delegate_to: web1
  changed_when: false

# Check replication status on web2
- name: Check replication status on web2
  mysql_query:
    login_unix_socket: /var/run/mysqld/mysqld.sock
    query: "SHOW SLAVE STATUS;"
  register: web2_replication_status
  delegate_to: web2
  changed_when: false
EOL
        then
            output_status "Create the MariaDB Replication tasks file" "Done" "$GREEN"
        else
            output_status "Create the MariaDB Replication tasks file" "Error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 25: Create role to deploy NFS Server on the LoadBalancing Server #
#########################################################################

create_nfs_setup_playbook() {
    local playbook_file="/etc/ansible/roles/nfs_server_setup/tasks/main.yml"

    if [ -f "$playbook_file" ]; then
        # File already exists
        output_status "Create the NFS Setup playbook" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/nfs_setup/tasks && cat <<EOL > "$playbook_file"
---
- name: Install necessary packages
  apt:
    name:
      - nfs-kernel-server
      - mariadb-client
    state: present
    update_cache: yes

# Check if the web group exists on LoadBalancing server
- name: Check if web group exists on LoadBalancing server
  command: getent group web
  register: group_exists
  ignore_errors: yes  # Ignore error if group is not found

# Create web group if it does not exist
- name: Create web group if it does not exist
  group:
    name: web
    gid: 1002
  when: group_exists.rc != 0  # If group does not exist (return code != 0)

# Check if the web user exists on LoadBalancing server
- name: Check if web user exists on LoadBalancing server
  command: getent passwd web
  register: user_exists
  ignore_errors: yes

# Create web user if it does not exist
- name: Create web user if it does not exist
  user:
    name: web
    uid: 1002
    group: web
    home: /srv/nfs/wordpress
    createhome: no
    shell: /bin/bash
  when: user_exists.rc != 0  # Execute task if return code is not 0

# NFS setup
- name: Check if WordPress directory exists
  stat:
    path: "{{ nfs_wordpress_path }}"
  register: wordpress_directory

- name: Display current permissions on /srv
  command: ls -la /srv
  register: srv_listing
  ignore_errors: yes

- name: Show contents of /srv
  debug:
    var: srv_listing.stdout_lines

- name: Create nested directories for WordPress if they do not exist
  file:
    path: "{{ nfs_wordpress_path }}"
    state: directory
    owner: web
    group: web
    mode: '0755'
    recurse: yes

- name: Add NFS export to /etc/exports
  lineinfile:
    path: /etc/exports
    line: "{{ nfs_wordpress_path }} {{ item }}({{ nfs_exports_options }})"
    create: yes
  loop: "{{ nfs_allowed_clients }}"

- name: Apply NFS changes
  command: exportfs -ra

- name: Check NFS export
  command: exportfs -v
  register: exportfs_output

- name: Set port for mountd in /etc/default/nfs-kernel-server
  lineinfile:
    path: /etc/default/nfs-kernel-server
    regexp: '^MOUNTD_PORT='
    line: "MOUNTD_PORT={{ nfs_mountd_port }}"
    create: yes

- name: Restart NFS server
  service:
    name: nfs-kernel-server
    state: restarted

- name: Restart rpcbind
  service:
    name: rpcbind
    state: restarted

- name: Enable NFS server on startup
  service:
    name: nfs-kernel-server
    enabled: yes
EOL
        then
            output_status "Create the NFS Setup playbook" "Done" "$GREEN"
        else
            output_status "Create the NFS Setup playbook" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 26: Create a file with variables for NFS server setup          #
#########################################################################

create_nfs_variables_file() {
    local variables_file="/etc/ansible/roles/nfs_server_setup/defaults/main.yml"

    if [ -f "$variables_file" ]; then
        # File already exists
        output_status "Create the NFS Variables file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/nfs_server_setup/defaults && cat <<EOL > "$variables_file"
nfs_wordpress_path: /srv/nfs/wordpress
nfs_allowed_clients:
  - 172.21.0.3
  - 172.21.0.4
nfs_mountd_port: 20048
nfs_exports_options: "rw,sync,no_subtree_check,no_root_squash"
EOL
        then
            output_status "Create the NFS Variables file" "Done" "$GREEN"
        else
            output_status "Create the NFS Variables file" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 27: Create a role to mount the NFS filesystem on the webservers  #
#########################################################################

create_nfs_client_mount_role() {
    local tasks_file="/etc/ansible/roles/nfs_client_mount/tasks/main.yml"

    if [ -f "$tasks_file" ]; then
        # File already exists
        output_status "Create the NFS Client Mount role" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/nfs_client_mount/tasks && cat <<EOL > "$tasks_file"
---
- name: Check hostname
  debug:
    msg: "Current hostname: {{ ansible_hostname }}"

- name: Install NFS client
  apt:
    name: nfs-common
    state: present
    update_cache: yes

- name: Check if WordPress directory exists
  stat:
    path: /var/www/web/public_html
  register: wordpress_directory

- name: Assert WordPress directory exists
  assert:
    that:
      - wordpress_directory.stat.exists
    fail_msg: "Directory /var/www/web/public_html does not exist"

- name: Create WordPress directory if it does not exist
  file:
    path: /var/www/web/public_html
    state: directory
    owner: web
    group: web
    mode: '0755'
  when: not wordpress_directory.stat.exists

- name: Check mount status on Webserver1
  shell: "mount | grep /var/www/web/public_html || true"
  register: mount_status_web1
  when: "'web1' in inventory_hostname"

- name: Debug information mount on Webserver1
  debug:
    msg: "Mount status on Webserver1: {{ mount_status_web1.stdout }}"
  when: mount_status_web1 is defined and 'stdout' in mount_status_web1

- name: Check mount status on Webserver2
  shell: "mount | grep /var/www/web/public_html || true"
  register: mount_status_web2
  when: "'web2' in inventory_hostname"

- name: Debug information mount on Webserver2
  debug:
    msg: "Mount status on Webserver2: {{ mount_status_web2.stdout }}"
  when: mount_status_web2 is defined and 'stdout' in mount_status_web2

- name: Mount NFS share on Webserver1
  mount:
    src: "172.21.0.1:/srv/nfs/wordpress"
    path: /var/www/web/public_html
    fstype: nfs
    opts: defaults
    state: mounted
  when: "'web1' in inventory_hostname"

- name: Mount NFS share on Webserver2
  mount:
    src: "172.21.0.1:/srv/nfs/wordpress"
    path: /var/www/web/public_html
    fstype: nfs
    opts: defaults
    state: mounted
  when: "'web2' in inventory_hostname"

- name: Add fstab entry for Webserver1
  lineinfile:
    path: /etc/fstab
    line: "172.21.0.1:/srv/nfs/wordpress /var/www/web/public_html nfs defaults 0 0"
  when: "'web1' in inventory_hostname"

- name: Add fstab entry for Webserver2
  lineinfile:
    path: /etc/fstab
    line: "172.21.0.1:/srv/nfs/wordpress /var/www/web/public_html nfs defaults 0 0"
  when: "'web2' in inventory_hostname"
EOL
        then
            output_status "Create the NFS Client Mount role" "Done" "$GREEN"
        else
            output_status "Create the NFS Client Mount role" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 28: Create a role to install WordPress in the NFS directory     #
#########################################################################

create_wordpress_install_role() {
    local tasks_file="/etc/ansible/roles/wordpress_install/tasks/main.yml"

    if [ -f "$tasks_file" ]; then
        # File already exists
        output_status "Create the WordPress Install role" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/wordpress_install/tasks && cat <<EOL > "$tasks_file"
---
- name: Download and install WordPress
  get_url:
    url: https://wordpress.org/latest.tar.gz
    dest: /srv/nfs/wordpress/latest.tar.gz

- name: Unarchive WordPress
  unarchive:
    src: /srv/nfs/wordpress/latest.tar.gz
    dest: /srv/nfs/wordpress
    remote_src: yes

- name: Install rsync
  apt:
    name: rsync
    state: present
    update_cache: yes

- name: Check if the WordPress files directory exists
  stat:
    path: /srv/nfs/wordpress/wordpress
  register: wordpress_directory_exists

- name: Set owner and group for WordPress files
  file:
    path: /srv/nfs/wordpress/wordpress
    owner: web
    group: web
    recurse: yes
  when: wordpress_directory_exists.stat.exists == true

- name: Copy WordPress files to main directory using rsync
  synchronize:
    src: /srv/nfs/wordpress/wordpress/
    dest: /srv/nfs/wordpress/
    owner: yes
    group: yes
    recursive: yes
  when: wordpress_directory_exists.stat.exists == true

- name: Remove empty WordPress directory
  file:
    path: /srv/nfs/wordpress/wordpress
    state: absent
    force: yes
  when: wordpress_directory_exists.stat.exists == true

- name: Remove downloaded archive
  file:
    path: /srv/nfs/wordpress/latest.tar.gz
    state: absent

- name: Set permissions on WordPress directory
  file:
    path: /srv/nfs/wordpress
    owner: web
    group: web
    recurse: yes
    mode: '0755'
EOL
        then
            output_status "Create the WordPress Install role" "Done" "$GREEN"
        else
            output_status "Create the WordPress Install role" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 29: Create role for WordPress configuration                    #
#########################################################################
create_wordpress_config_role() {
    local tasks_file="/etc/ansible/roles/wordpress_config/tasks/main.yml"

    if [ -f "$tasks_file" ]; then
        # File already exists
        output_status "Create the WordPress Config role" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/wordpress_config/tasks && cat <<'EOL' > "$tasks_file"
---
- name: Check if wp-config.php exists
  stat:
    path: /var/www/web/public_html/wp-config.php
  register: wp_config_exists

- name: Copy wp-config-sample.php to wp-config.php if it does not exist
  copy:
    src: /var/www/web/public_html/wp-config-sample.php
    dest: /var/www/web/public_html/wp-config.php
    owner: web
    group: web
    mode: '0644'
    remote_src: yes
  when: wp_config_exists.stat.exists == false

- name: Configure database parameters in wp-config.php
  lineinfile:
    path: /var/www/web/public_html/wp-config.php
    regexp: "^define\\(\\s*'{{ item.key }}'"
    line: "define( '{{ item.key }}', '{{ item.value }}' );"
  loop:
    - { key: 'DB_NAME', value: 'wordpress_db' }
    - { key: 'DB_USER', value: '{{ mariadb_wp_db_user }}' }
    - { key: 'DB_PASSWORD', value: '{{ mariadb_wp_db_password }}' }
    - { key: 'DB_HOST', value: "{{ hostvars['web1'].ansible_host }}" }

- name: Set correct permissions on wp-config.php
  file:
    path: /var/www/web/public_html/wp-config.php
    owner: web
    group: web
    mode: '0644'

# Install wp-cli
- name: Download wp-cli
  get_url:
    url: https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
    dest: /usr/local/bin/wp
    mode: '0755'

- name: Install WordPress using wp-cli
  command: >
    sudo -u web wp core install
    --url="http://testtask.com"
    --title="My WordPress Site"
    --admin_user="admin"
    --admin_password="testtask"
    --admin_email="support@testtask.com"
    --path=/var/www/web/public_html
  args:
    chdir: /var/www/web/public_html
EOL
        then
            output_status "Create the WordPress Config role" "Done" "$GREEN"
        else
            output_status "Create the WordPress Config role" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 30: Create a role for certificate generation with variables      #
#########################################################################

create_certificate_generation_role() {
    local defaults_file="/etc/ansible/roles/certificate_generation/defaults/main.yml"

    if [ -f "$defaults_file" ]; then
        # File already exists
        output_status "Create the Certificate Generation role" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/certificate_generation/defaults && cat <<EOL > "$defaults_file"
cert_days: 365
cert_key_length: 2048
cert_country: "US"
cert_state: "Some-State"
cert_locality: "Some-City"
cert_organization: "Test Organization"
cert_organizational_unit: "IT"
cert_common_name: "{{ server_name }}"
cert_email: "admin@{{ server_name }}"
ssl_cert_dir: "/etc/ssl/{{ server_name }}"
ssl_cert_file: "{{ ssl_cert_dir }}/{{ server_name }}.crt"
ssl_cert_key_file: "{{ ssl_cert_dir }}/{{ server_name }}.key"
EOL
        then
            output_status "Create the Certificate Generation role" "Done" "$GREEN"
        else
            output_status "Create the Certificate Generation role" "error" "$RED"
            exit 1
        fi
    fi
}

#########################################################################
# Step 31: Create a role file to describe tasks for certificate generation #
#########################################################################

create_certificate_generation_tasks_file() {
    local tasks_file="/etc/ansible/roles/certificate_generation/tasks/main.yml"

    if [ -f "$tasks_file" ]; then
        # File already exists
        output_status "Create the Certificate Generation tasks file" "Already created" "$YELLOW"
    else
        # Try to create the file with the specified content
        if mkdir -p /etc/ansible/roles/certificate_generation/tasks && cat <<EOL > "$tasks_file"
---
- name: Install OpenSSL for certificate generation
  apt:
    name: openssl
    state: present
  when: ansible_os_family == "Debian"

- name: Create directory for SSL certificates
  file:
    path: "{{ ssl_cert_dir }}"
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Check if SSL certificate already exists
  stat:
    path: "{{ ssl_cert_file }}"
  register: cert_stat

- name: Generate a self-signed SSL certificate
  command: |
    openssl req -x509 -nodes -days {{ cert_days }} \
    -newkey rsa:{{ cert_key_length }} -keyout {{ ssl_cert_key_file }} \
    -out {{ ssl_cert_file }} -subj "/C={{ cert_country }}/ST={{ cert_state }}/L={{ cert_locality }}/O={{ cert_organization }}/OU={{ cert_organizational_unit }}/CN={{ cert_common_name }}/emailAddress={{ cert_email }}"
  when: not cert_stat.stat.exists
  notify: reload_apache
EOL
        then
            output_status "Create the Certificate Generation tasks file" "Done" "$GREEN"
        else
            output_status "Create the Certificate Generation tasks file" "error" "$RED"
            exit 1
        fi
    fi
}
#########################################################################
# Step 32: Create a role file to describe variables for HAProxy setup       #
#########################################################################

create_haproxy_defaults() {
    local defaults_file="/etc/ansible/roles/haproxy_install/defaults/main.yml"

    if [ -f "$defaults_file" ]; then
        # The file already exists
        echo "HAProxy defaults already exist at $defaults_file"
    else
        # Create a file with the required variables
        if mkdir -p /etc/ansible/roles/haproxy_install/defaults && cat <<EOL > "$defaults_file"
haproxy_frontend_http_port: 80
haproxy_frontend_https_port: 443
haproxy_backend_servers:
  - { name: "web1", address: "172.21.0.3", port: "443" }
  - { name: "web2", address: "172.21.0.4", port: "443" }
ssh_port: 7856
ssh_private_key: /home/deploy/.ssh/id_rsa
EOL
        then
            echo "HAProxy defaults created successfully at $defaults_file"
        else
            echo "Failed to create HAProxy defaults"
            exit 1
        fi
    fi
}

#########################################################################
# Step 33: Create a handler for restarting HAProxy                      #
#########################################################################

create_haproxy_handler() {
    local handler_file="/etc/ansible/roles/haproxy_install/handlers/main.yml"

    if [ -f "$handler_file" ]; then
        # The file already exists
        echo "HAProxy handler already exists at $handler_file"
    else
        # Создаем файл с задачей для перезапуска HAProxy
        if mkdir -p /etc/ansible/roles/haproxy_install/handlers && cat <<EOL > "$handler_file"
---
- name: Restart HAProxy
  service:
    name: haproxy
    state: restarted
EOL
        then
            echo "HAProxy handler created successfully at $handler_file"
        else
            echo "Failed to create HAProxy handler"
            exit 1
        fi
    fi
}

#########################################################################
# Step 34: Create tasks for installing and configuring HAProxy          #
#########################################################################

create_haproxy_tasks() {
    local tasks_file="/etc/ansible/roles/haproxy_install/tasks/main.yml"

    if [ -f "$tasks_file" ]; then
        # The file already exists
        echo "HAProxy tasks file already exists at $tasks_file"
    else
        # Create a file with tasks for installing and configuring HAProxy
        if mkdir -p /etc/ansible/roles/haproxy_install/tasks && cat <<EOL > "$tasks_file"
---
- name: Remove HAProxy and purge its configuration files
  apt:
    name: haproxy
    state: absent
    purge: yes

- name: Install HAProxy
  apt:
    name: haproxy
    state: present
    update_cache: yes

- name: Check if HAProxy config exists
  stat:
    path: /etc/haproxy/haproxy.cfg
  register: haproxy_cfg

- name: Backup original HAProxy config if it exists
  copy:
    src: /etc/haproxy/haproxy.cfg
    dest: /etc/haproxy/haproxy.cfg_orig
    backup: yes
  when: haproxy_cfg.stat.exists

- name: Ensure necessary directories exist
  file:
    path: "{{ item }}"
    state: directory
    owner: haproxy
    group: haproxy
    mode: '0755'
  with_items:
    - /etc/haproxy
    - /etc/haproxy/certs

- name: Create HAProxy config from template
  template:
    src: haproxy.cfg.j2
    dest: /etc/haproxy/haproxy.cfg
    owner: root
    group: root
    mode: '0644'

- name: Ensure /etc/ssl/testtask.com exists on web1
  file:
    path: /etc/ssl/testtask.com
    state: directory
    owner: root
    group: root
    mode: '0755'
  become: true
  delegate_to: web1

- name: Check if certificate and key exist on web1
  stat:
    path: "/etc/ssl/testtask.com/{{ item }}"
  register: cert_stat
  with_items:
    - testtask.com.crt
    - testtask.com.key
  delegate_to: web1

- name: Concatenate certificate and key into PEM on web1
  shell: cat /etc/ssl/testtask.com/testtask.com.crt /etc/ssl/testtask.com/testtask.com.key > /etc/ssl/testtask.com/testtask.com.pem
  args:
    creates: /etc/ssl/testtask.com/testtask.com.pem
  become: true
  delegate_to: web1
  when: cert_stat.results[0].stat.exists and cert_stat.results[1].stat.exists

- name: Copy SSL certificate from web1 to load-balancing using SCP
  shell: scp -P {{ ssh_port }} -i {{ ssh_private_key }} deploy@{{ item.address }}:/etc/ssl/testtask.com/testtask.com.pem /etc/haproxy/certs/testtask.com.pem
  args:
    creates: /etc/haproxy/certs/testtask.com.pem
  with_items: "{{ haproxy_backend_servers }}"
  when: item.name == "web1"

- name: Set correct permissions for PEM file
  file:
    path: /etc/haproxy/certs/testtask.com.pem
    owner: haproxy
    group: haproxy
    mode: '0600'

- name: Restart HAProxy
  service:
    name: haproxy
    state: restarted
EOL
        then
            echo "HAProxy tasks file created successfully at $tasks_file"
        else
            echo "Failed to create HAProxy tasks file"
            exit 1
        fi
    fi
}

#########################################################################
# Step 35: Create the HAProxy configuration template                    #
#########################################################################

create_haproxy_template() {
    local template_file="/etc/ansible/roles/haproxy_install/templates/haproxy.cfg.j2"

    if [ -f "$template_file" ]; then
        # The file already exists
        echo "HAProxy configuration template already exists at $template_file"
    else
        # Create a HAProxy configuration template file
        if mkdir -p /etc/ansible/roles/haproxy_install/templates && cat <<EOL > "$template_file"
global
    log /dev/log local0 info
    log /dev/log local1 debug
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

defaults
    log     global
    option tcplog
    option  dontlognull
    timeout connect 5000ms
    timeout client  50000ms
    timeout server  50000ms
    errorfile 400 /etc/haproxy/errors/400.http
    errorfile 403 /etc/haproxy/errors/403.http
    errorfile 408 /etc/haproxy/errors/408.http
    errorfile 500 /etc/haproxy/errors/500.http
    errorfile 502 /etc/haproxy/errors/502.http
    errorfile 503 /etc/haproxy/errors/503.http
    errorfile 504 /etc/haproxy/errors/504.http

frontend http_front
    bind *:{{ haproxy_frontend_http_port }}
    mode http
    redirect scheme https code 301 if !{ ssl_fc }

frontend https_front
    bind *:{{ haproxy_frontend_https_port }} ssl crt /etc/haproxy/certs/testtask.com.pem alpn http/1.1 ssl-min-ver TLSv1.2
    mode tcp
    default_backend web_servers

backend web_servers
    mode tcp
    balance roundrobin
    option tcp-check
    {% for server in haproxy_backend_servers %}
    server {{ server.name }} {{ server.address }}:{{ server.port }} ssl verify none check
    {% endfor %}
EOL
        then
            echo "HAProxy configuration template created successfully at $template_file"
        else
            echo "Failed to create HAProxy configuration template"
            exit 1
        fi
    fi
}

#########################################################################
# Step 36: Create the HAProxy custom 400 error page                     #
#########################################################################

create_haproxy_error_page_400() {
    local error_page_file="/etc/ansible/roles/haproxy_install/files/error_pages/400.http"

    if [ -f "$error_page_file" ]; then
        # Файл уже существует
        echo "HAProxy 400 error page already exists at $error_page_file"
    else
        # Создаем файл HAProxy 400 error page
        if mkdir -p /etc/ansible/roles/haproxy_install/files/error_pages && cat <<EOL > "$error_page_file"
HTTP/1.0 400 Bad request
Content-Type: text/html

<html>
<head><title>400 Bad Request</title></head>
<body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.</p>
</body>
</html>
EOL
        then
            echo "HAProxy 400 error page created successfully at $error_page_file"
        else
            echo "Failed to create HAProxy 400 error page"
            exit 1
        fi
    fi
}

#########################################################################
# Step 1X: Create general playbook for managing all roles               #
#########################################################################

create_general_playbook() {
    local playbook_file="/etc/ansible/playbooks/site.yml"

    if [ -f "$playbook_file" ]; then
        # File already exists
        output_status "Create the general playbook" "Already created" "$YELLOW"
    else
        # Try to create the playbook with the specified content
        if mkdir -p /etc/ansible/playbooks && cat <<EOL > "$playbook_file"
---
# Setting up an NFS server and installing WordPress
- hosts: loadbalancing
  become: true
  vars_files:
    - /etc/ansible/vars/secrets.yml
  roles:
    - nfs_server_setup
    - wordpress_install
    - firewall

# WordPress configuration on web1
- hosts: webservers
  become: true
  vars_files:
    - /etc/ansible/vars/secrets.yml
  roles:
    - apache_install
    - php_install
    - vhost_configuration
    - user_management
    - certificate_generation
    - firewall
    - hosts_management
    - mariadb_install
    - mariadb_replication
    - nfs_client_mount

# WordPress configuration on web1 to the NFS Share
- hosts: web1
  become: true
  vars_files:
    - /etc/ansible/vars/secrets.yml
  roles:
    - wordpress_config  # Настройка WordPress на web1

# Installing and Configuring HAProxy
- hosts: loadbalancing
  become: true
  vars_files:
    - /etc/ansible/vars/secrets.yml
  roles:
    - haproxy_install
EOL
        then
            output_status "Create the general playbook" "Done" "$GREEN"
        else
            output_status "Create the general playbook" "error" "$RED"
            exit 1
        fi
    fi
}

display_manual_actions_message() {
    # Define colors for output using tput
    local YELLOW
    local RED
    local WHITE
    local RESET

    YELLOW=$(tput setaf 3)
    RED=$(tput setaf 1)
    WHITE=$(tput setaf 7)
    RESET=$(tput sgr0)

    # Print message with custom colors
    echo "${WHITE}"
    echo "!!!!Please perform the following actions manually!!!!!"
    echo "!!!!Create Encrypted Variables with Ansible Vault to store passwords in a secure place!!!!!"
    echo "${RED}-------------------------------------------------------------------------------------------------${WHITE}"
    echo "- Run in the console                                                                            -"
    echo "- 1. export EDITOR=nano                                                                         -"
    echo "- 2. ansible-vault create /etc/ansible/vars/secrets.yml (Set the password for the file)         -"
    echo "${RED}-------------------------------------------------------------------------------------------------${WHITE}"
    echo "- And add variables to the /etc/ansible/vars/secrets.yml where you can define the password      -"
    echo "- mariadb_root_password: your_password                                                          -"
    echo "- mariadb_replication_user: repl_user                                                           -"
    echo "- mariadb_replication_password: your_password                                                   -"
    echo "- mariadb_wp_db_user: wp_user                                                                   -"
    echo "- mariadb_wp_db_password: your_password                                                         -"
    echo "${RED}-------------------------------------------------------------------------------------------------${RESET}"
    echo ""
    echo "${YELLOW}Run the Test command to make sure that Ansible may connect to the remote hosts:"
    echo "export ANSIBLE_HOST_KEY_CHECKING=False;ansible all -m ping -i /etc/ansible/hosts"
    echo ""
    echo "If all looks fine, please run (where you need to enter the pass from the step above):"
    echo "ansible-playbook /etc/ansible/playbooks/site.yml --ask-vault-pass"
    echo "${RESET}"
}

# Execute steps

#Step 1
install_ansible

# Step 2
install_ansible_galaxy

# Step 3
create_ansible_cfg

# Step 4
create_inventory_file

# Step 5
create_directory_structure

# Step 6
create_apache_variables_file

# Step 7
create_apache_tasks_file

# Step 8
create_apache_handlers_file

# Step 9
create_php_variables_file

# Step 10
create_php_tasks_file

# Step 11
create_php_fpm_template

# Step 12
create_php_fpm_handlers_file

#Step 13
create_user_management_variables_file

#Step 14
create_user_management_tasks_file

#Step 15
create_vhost_tasks_file

#Step 16
create_vhost_template

#Step 17
create_mariadb_tasks_file

#Step 18
create_mariadb_template

#Step 19
create_mariadb_handler_file

#Step 20
create_mariadb_vars_file

#Step 21
create_firewall_tasks_file

#Step 22
create_firewall_vars_file

#Step 23
create_hosts_management_tasks_file

#Step 24
create_mariadb_replication_tasks_file

#Step 25
create_nfs_setup_playbook

#Step 26
create_nfs_variables_file

#Step 27
create_nfs_client_mount_role

#Step 28
create_wordpress_install_role

#Step 29
create_wordpress_config_role

#Step 30
create_certificate_generation_role

#Step 31
create_certificate_generation_tasks_file

# Step 32
create_haproxy_defaults

# Step 33
create_haproxy_handler

# Step 34
create_haproxy_tasks

# Step 35
create_haproxy_template

# Step 36
create_haproxy_error_page_400

#Step 1X
create_general_playbook

# Step 2X
display_manual_actions_message
